---
title: 跳楼梯
date: 2024-11-20 22:30:11
categories:
- 动态规划
- 0070:跳楼梯
---
### 题目

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？


### 示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
示例 2：

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
 
### 提示：
1 <= n <= 45

### 解体思路
这是一道经典的动态规划题目，满足动态规划的四大条件：
- 重叠子问题
- 最优子结构
- 有边界状态且状态满足无后效性
- 有递推公式

递推公式：
```
跳到第i格两种方式，首先跳到i-1格，下一次跳一格为第一种方式；跳到i-2格，
下一次跳两格为第二种方式。跳到第i格可以分解为这两个子问题并求和。
F(i) = F(i-1) + F(i-2) 
F(1) = 1
f(2) = 2
F(i)表示跳到第i阶楼梯的方法数
```

基于递推公式可以考虑使用dp[i+1]长度的数组存储递推过程中的状态，自下而上完成计算。


### rust代码

```rust
pub fn climb_stairs(n: i32) -> i32 {
    let n = n as usize;
    let mut dp = vec![0; 2];
    if n >= 1 {
        dp[1] = 1;
    }
    if n >= 2 {
        dp[0] = 2;
    }
    if n >= 3 {
        for i in 3..=n {
            dp[i % 2] = dp[(i - 1) % 2] + dp[(i - 2) % 2];
        }
    }
    dp[n % 2]
}
```

![rust](20241120-跳楼梯/rust.png)



### python3代码

```python3
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [0, 0]
        if n >= 1:
            dp[1] = 1
        if n >= 2:
            dp[0] = 2
        for i in range(3,n+1):
            dp[i % 2] = dp[(i - 1) % 2] + dp[(i - 2) % 2]
        return dp[n % 2]
```
![rust](20241120-跳楼梯/python3.png)
